import { useState, useEffect, useContext } from 'react';
import { AppContext } from '@/components/AppContext';
import { AppContextProps } from '@/types';
import { collection, query, where, getDocs, orderBy, Timestamp } from 'firebase/firestore';
import { firestoreDB } from '@/utils/firebase/firebase.config';

export interface Payment {
    id: string;
    courseId?: string;
    courseName?: string;
    productId?: string;
    productName?: string;
    amount?: number;
    currency?: string;
    formattedAmount?: string;
    status?: string;
    date?: string | Date | Timestamp;
    customerId?: string;
    invoiceId?: string;
    invoiceUrl?: string;
    paymentMethod?: string;
    metadata?: Record<string, any>;
}

export interface PaymentHistoryData {
    payments: Payment[];
    loading: boolean;
    error: string | null;
    downloadInvoice: (paymentId: string) => Promise<string | null>;
}

export default function usePaymentHistory(): PaymentHistoryData {
    const { user, userPaidProducts = [], courses = {}, products = [], subscriptions = [] } = useContext(AppContext) as AppContextProps;

    const [payments, setPayments] = useState<Payment[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function fetchPaymentHistory() {
            if (!user) {
                setPayments([]);
                setLoading(false);
                return;
            }

            try {
                // Fetch ONLY from invoices collection (subscription payments with invoice_pdf)
                // This shows only the actual invoices generated by Stripe for subscription payments
                const invoicesRef = collection(firestoreDB, `customers/${user.uid}/invoices`);
                const invoicesSnap = await getDocs(invoicesRef);

                const paymentsList: Payment[] = [];

                // Process invoices (subscription payments)
                invoicesSnap.forEach(doc => {
                    const invoiceData = doc.data();

                    // Extract product ID from subscription line items
                    let productId = invoiceData.lines?.data?.[0]?.price?.product || '';

                    // Find product or subscription name
                    let productName = 'Subscription Payment';

                    if (productId) {
                        const subscription = subscriptions.find(s => s.product?.id === productId);
                        if (subscription && subscription.product) {
                            productName = subscription.product.name || 'Subscription';
                        } else {
                            const product = products.find(p => p.id === productId);
                            if (product) {
                                productName = product.name || 'Product';
                            }
                        }
                    }

                    // Handle amount - invoice amounts are in cents
                    const rawAmount = invoiceData.amount_paid ?? invoiceData.total ?? 0;
                    const amount = rawAmount / 100;

                    // Handle currency
                    const currency = (invoiceData.currency || 'RON').toUpperCase();

                    // Handle date - invoices use created timestamp
                    let date: Date;
                    if (invoiceData.created) {
                        date = new Date(invoiceData.created * 1000);
                    } else if (invoiceData.period_end) {
                        date = new Date(invoiceData.period_end * 1000);
                    } else {
                        date = new Date();
                    }

                    const payment: Payment = {
                        id: doc.id,
                        productId: productId,
                        productName: productName,
                        amount: amount,
                        currency: currency,
                        formattedAmount: `${amount.toFixed(2)} ${currency}`,
                        status: invoiceData.status === 'paid' ? 'succeeded' : invoiceData.status,
                        date: date,
                        customerId: invoiceData.customer,
                        invoiceUrl: invoiceData.invoice_pdf || invoiceData.hosted_invoice_url,
                        paymentMethod: invoiceData.payment_intent?.payment_method_types?.[0] || 'card',
                        metadata: invoiceData.metadata || {},
                    };

                    paymentsList.push(payment);
                });

                // Sort by date in descending order
                paymentsList.sort((a, b) => {
                    const dateA = a.date instanceof Date ? a.date : (a.date && typeof a.date === 'object' && 'toDate' in a.date ? a.date.toDate() : new Date(a.date!));
                    const dateB = b.date instanceof Date ? b.date : (b.date && typeof b.date === 'object' && 'toDate' in b.date ? b.date.toDate() : new Date(b.date!));
                    return dateB.getTime() - dateA.getTime();
                });

                setPayments(paymentsList);
                setLoading(false);
            } catch (err) {
                console.error("Error fetching payment history:", err);
                setError("Failed to load payment history");
                setLoading(false);
            }
        }

        fetchPaymentHistory();
    }, [user, courses, products, subscriptions]);

    const downloadInvoice = async (paymentId: string): Promise<string | null> => {
        if (!user) return null;

        try {
            // Find the payment in our existing array
            const payment = payments.find(p => p.id === paymentId);
            if (!payment) return null;

            // If we already have an invoice URL, return it directly
            if (payment.invoiceUrl) {
                return payment.invoiceUrl;
            }

            // If no invoice URL is available, we can't generate it
            // (Stripe invoices are created by Stripe, not by our API)
            console.warn('No invoice URL available for payment:', paymentId);
            return null;
        } catch (err) {
            console.error("Error getting invoice URL:", err);
            return null;
        }
    };

    return {
        payments,
        loading,
        error,
        downloadInvoice
    };
}
